# 더 부드럽게 동작하는 고화질 비디오

## 부드러운 감속의 원리
이미지 시퀀스, object 이동 등 Mac의 가속도 스크롤이 적용된것 같은 자연스러운 감속을 적용하는 수식

```javascript
let acc = 0.1;
let delayedYOffset = 0;

function loop() {
  delayedYOffset = delayedYOffset + (pageYOffset - delayedYOffset) * acc;
  requestAnimationFrame(loop); 
}
```

원리는, 처음엔 빠르게 → 나중엔 느리게 동작 시키는 것이다.  
이동하는 과정을 통해 수식의 원리를 알아보자.  

시작 위치(c)부터 목표 위치까지 10%씩 이동한다고 가정해보자.

c1 위치는 다음과 같이 구할 수 있다.

전체 구간에서 현재 위치까지의 거리를 뺀 값에서 10%(acc)를 곱하면,  
이동하고자하는 거리가 나온다.

<img width="789" alt="스크린샷 2020-07-26 오후 3 01 59" src="https://user-images.githubusercontent.com/26196090/88472726-f9975800-cf50-11ea-894e-fe57e4ec8b33.png">


```
c1 = (d - c) * acc
```
다시 생각해보면,  
초기 위치(c)에서 위 값을 더한 위치이기 때문에, 수식은 이렇게 정리할 수 있다.

```
c1 = c + (d - c) * acc
```

c2의 위치는 다음과 같이 구할 수 있다.

<img width="783" alt="스크린샷 2020-07-26 오후 3 11 57" src="https://user-images.githubusercontent.com/26196090/88472854-5cd5ba00-cf52-11ea-9255-dd344ef04329.png">


```
c2 = c1 + (d - c1) * acc
```

c3도 마찬가지이다.  
<img width="786" alt="스크린샷 2020-07-26 오후 3 13 24" src="https://user-images.githubusercontent.com/26196090/88472873-90b0df80-cf52-11ea-9bbd-eb6ff41eb839.png">

```
c3 = c2 + (d - c2) * acc
```


### 정리
수식을 다시 정리해보자.

- delayedYOffset: 현재 나의 위치
- pageYOffset: 현재 스크롤 위치

즉, 스크롤바가 위치한 곳(pageYOffset)까지 가기 위해서 object의 위치(delayedYOffset)를 어떻게 변화를 줄 것인지에 대한 수식이라고 보면 된다.

```
delayedYOffset = delayedYOffset + (pageYOffset - delayedYOffset) * acc;
```

### requestAnimationFrame 정리
requestAnimationFrame을 cancel해주기 위해서는, (목표 위치 - 시작 위치)의 차이가 거의 없는지를 통해 제어할 수 있다.  

이 차이를 절대값(`Math.abs()`)을 사용한 이유는,  
아래로 페이지가 이동된다면, `pageYOffset > delayedYOffset`이기 때문에 정상이지만,  
위로 페이지가 이동된다면, `pageYOffset < delayedYOffset`로 음수가 나오게 되어 부드러운 감속이 되지 않는다.  

거리만 판별하면 되기때문에, 절대값을 사용하였다.

```javascript
const box = document.querySelector('.box');
let acc = 0.1;
let delayedYOffset = 0;
let rafId;
let rafState;

function loop() {
  delayedYOffset = delayedYOffset + (pageYOffset - delayedYOffset) * acc;
  box.style.width = `${delayedYOffset}px`;

  rafId = requestAnimationFrame(loop);
  
  if (Math.abs(pageYOffset - delayedYOffset) < 1) { // 둘의 차이가 1보다 작을때
    cancelAnimationFrame(rafId);
    rafState = false;
  } else {
    console.log(pageYOffset +', ' + delayedYOffset);

  }
}

loop();

window.addEventListener('scroll', () => {
  // box.style.width = `${window.pageYOffset}px`;
  console.log('rafState', rafState);
  if (!rafState) {
    rafId = requestAnimationFrame(loop);
    rafState = true;
  }
});
```

## 부드러운 감속 비디오에 적용하기
부드러운 감속에서 구한 `delayedYOffset`을 canvas에 적용해준다.

```javascript
let acc = 0.1;
let delayedYOffset = 0;
let rafId;
let rafState;

const loop = () => {
  delayedYOffset = delayedYOffset + (yOffset - delayedYOffset) * acc;
  const currentYOffset = delayedYOffset - prevScrollHeight; // 현재 활성화 섹션 기준으로 얼만큼 스크롤 되었는지
  const objs = sceneInfo[currentScene].objs;
  const values = sceneInfo[currentScene].values;

  if(currentScene == 0) {
    let sequence = Math.round(calcValues(values.imageSequence, currentYOffset)); // image index를 위한 변수
    objs.context.drawImage(objs.videoImages[sequence], 0, 0); // canvas에 그리기
  }

  rafId = requestAnimationFrame(loop);
  
  if (Math.abs(yOffset - delayedYOffset) < 1) {
    cancelAnimationFrame(rafId);
    rafState = false;
  } else {

  }
}
window.addEventListener('scroll', () => {
  yOffset = window.pageYOffset;
  scrollLoop();
  checkMenu();

  if(!rafState) {
    rafId = requestAnimationFrame(loop);
    rafState = true;
  }
});
```

역방향 스크롤시 아래와 같은 오류가 발생한다.  
그릴 이미지가 없다는 뜻이다.

<img width="467" alt="스크린샷 2020-08-17 오후 2 42 59" src="https://user-images.githubusercontent.com/26196090/90360953-f860d300-e097-11ea-8554-4f4141b3c82c.png">

![Aug-17-2020 14-49-27](https://user-images.githubusercontent.com/26196090/90361334-e59ace00-e098-11ea-9d8d-fd710464a371.gif)


이를 방지하기위해, 이미지가 존재할때만 그리도록 수정하자.  
```javascript
if(currentScene == 0) {
  let sequence = Math.round(calcValues(values.imageSequence, currentYOffset)); // image index를 위한 변수
  if(objs.videoImages[sequence]) { // 이미지가 존재할때
    objs.context.drawImage(objs.videoImages[sequence], 0, 0); // canvas에 그리기
  }
}
```

그런데, 이번엔 역방향시 첫번째 이미지가 잠깐 노출됐다가 사라진다.
![Aug-17-2020 14-52-45](https://user-images.githubusercontent.com/26196090/90361497-57731780-e099-11ea-8a10-9838710aa86e.gif)

이는 `requestAnimationFrame`을 이용해서 감속 오차를 조정하면서 발생하는 이슈이다.  
즉, scene이 바뀌는 순간이 문제가 되고 있다.  

사용했던 변수중에 `enterNewScene`이 있다.  
새로운 scene으로 바뀔때 계산의 오차가 생기는 것 때문에 scene이 바뀌는 순간에 일시적으로 true가 되면서 `playAnimation`을 실행하지 않도록 사용되었다.

loop함수에서는 `enterNewScene`이 false 일때 실행되도록 설정하자.  

즉, scene 0일때 계속 loop가 실행되도록하는 것이다.  2번 씬도 마찬가지이므로, 조건을 추가한다.

```javascript
const loop = () => {
  delayedYOffset = delayedYOffset + (yOffset - delayedYOffset) * acc;
  if(!enterNewScene) {
    
    if(currentScene == 0 || currentScene == 2) {
      const currentYOffset = delayedYOffset - prevScrollHeight; // 현재 활성화 섹션 기준으로 얼만큼 스크롤 되었는지
      const objs = sceneInfo[currentScene].objs;
      const values = sceneInfo[currentScene].values;
      let sequence = Math.round(calcValues(values.imageSequence, currentYOffset)); // image index를 위한 변수
      if(objs.videoImages[sequence]) {
        objs.context.drawImage(objs.videoImages[sequence], 0, 0); // canvas에 그리기
      }
    }
  }


  rafId = requestAnimationFrame(loop);
  
  if (Math.abs(yOffset - delayedYOffset) < 1) {
    cancelAnimationFrame(rafId);
    rafState = false;
  } else {

  }
}
```

2번 scene에서 이미지 시퀀스가 맞지않는 현상이 발생한다.  

원인은, 비디오 이미지의 경우 감속을 위해 deleydYOffset을 이용하고 있는데, scene이 바뀌는 순간을 제어하는 `scrollLoop` 함수에서는 yOffset을 사용하고 있어 scroll에 대한 기준이 서로 상이하기 때문이다.
다른 경우들은 yOffset을 사용해도 괜찮지만, 이미지 시퀀스로 처리하는 작업은 잠깐의 노출이 영향을 주기때문에 같은 scroll 값을 사용해야 한다.

```javascript
const scrollLoop = () => {
  enterNewScene = false;
  prevScrollHeight = 0;
  for (let i = 0, max = currentScene; i < max; i++) {
    prevScrollHeight += sceneInfo[i].scrollHeight;
  }

  // TODO: 이건 무슨 경우야?
  if (delayedYOffset > prevScrollHeight + sceneInfo[currentScene].scrollHeight) {
    enterNewScene = true;
    currentScene++;
    document.body.setAttribute('id', `show-scene-${currentScene}`);
  }
  // TODO: 이건 무슨 경우야?
  if (delayedYOffset < prevScrollHeight) {
    enterNewScene = true;
    if (currentScene === 0) return; // iOS 상단 바운스 대응
    currentScene--;
    document.body.setAttribute('id', `show-scene-${currentScene}`);
  }

  // 씬이 바뀌는 순간 이상한 값(비율 값이 음수 또는 이전 섹션의 큰 값)이 들어오는 것을 방지하기 위해, 씬이 바뀌는 순간에만 return 처리함
  if (enterNewScene) return;
  playAnimation();
};
```

![Aug-17-2020 15-09-07](https://user-images.githubusercontent.com/26196090/90362445-a0c46680-e09b-11ea-81b2-d7ea42ae7dc8.gif)

## 브라우저 리사이즈 대응
이미지 블랜드나 scale되는 영역은 리사이즈시 튀는 현상이 있다.  
원인는 브라우저 사이즈와 관련있는 값들이 갱신이 되지않았기 때문이다.

아래 영역이 갱신되어야 하위 관련 값들도 같이 변한다.

```javascript
if (!values.rectStartY) {
  // values.rectStartY = objs.canvas.getBoundingClientRect().top;
  values.rectStartY = objs.canvas.offsetTop + (objs.canvas.height - objs.canvas.height * canvasScaleRatio) / 2;
  values.rect1X[2].start = (window.innerHeight / 2) / scrollHeight; // 창 사이즈의 절반정도에서 시작되도록
  values.rect2X[2].start = (window.innerHeight / 2) / scrollHeight;
  values.rect1X[2].end = values.rectStartY / scrollHeight;
  values.rect2X[2].end = values.rectStartY / scrollHeight;
}
```

이를 개선하기 위해서 `resize`시에 초기화를 진행한다.  
아래 값이 0으로 초기화되면, `if (!values.rectStartY) {}` 이 구문 조건에 맞아 값들이 갱신될 것이다.

```javascript
window.addEventListener('resize', () => {
  // ... 중략

  sceneInfo[3].values.rectStartY = 0; // resize시 값이 갱신되도록 초기화함
});
```